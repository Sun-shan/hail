package org.broadinstitute.hail.driver

import java.io.{PrintWriter, Serializable}

import org.apache.commons.io.FileUtils
import org.broadinstitute.hail.utils.DockerRunner
import org.broadinstitute.hail.variant.{Genotype, Variant}
import org.broadinstitute.hail.annotations._
import org.kohsuke.args4j.{Option => Args4jOption}


/**
 * Base class for running containerized variant annotation application from within Hail.
 * It works by writing out a VCF file for each partition,
 * running the containerized application on that file, and then loading the result back up.
 */
abstract class DockerizedAnnotator extends Command with DockerRunner with Serializable {

  // Basic options for all sub classes.
  class DockerOptions extends BaseOptions {

    // Subclasses can provide a docker image to use for the container.
    // This parameters lets the user override that image
    // (if they know what they're doing).
    @Args4jOption(required = false, name = "-docker",usage = "Docker image to use")
    var dockerImageOption: String = defaultDockerImage
  }
  var options:Options = _

  def defaultDockerImage: String

  // Temporary input file to write the variants found in 1 partition.
  val vcfForPartition = s"$tmpDir/$uuid-in.vcf"

  /**
   * Runs annotate on each partition 
   */
  def run(state: State, options: Options): State = {
    this.options=options
    state.copy(vds = state.vds.copy(
      rdd = state.vds.rdd.mapPartitions(annotate))
    )
  }
  
  /**
   * Annotates the variants in a given partition. 
   */
  def annotate(partition: Iterator[(Variant, AnnotationData, Iterable[Genotype])]):
      Iterator[(Variant, AnnotationData, Iterable[Genotype])] = {

    // Unfortunately, we need to load all the variants in the partition into memory before we can process the vcf file.
    val data = partition.toList
    writeVcf(data)
    runDocker()

    // Read the annotations generated by docker and integrate them into our annotation object. 
    val vi = data.iterator
    val newPartition = readAnnotations.map(annotations => {
      val (variants,oldAnnotations,genotypes) = vi.next
      val newAnnotations = oldAnnotations.maps ++ Map(name -> annotations)
      (variants, new AnnotationData(newAnnotations, oldAnnotations.vals), genotypes)
    })
    
    // Cleanup
    FileUtils.deleteDirectory(tmpDir)

    newPartition
  }

  /**
   * Generate a VCF from the variants in this partition.
   * This implementation does not write existing annotations to the vcf (just the variant location itself).
   * Subclasses can override that behavior or use a proper VCF writer if desired.
   */
  def writeVcf(data:List[(Variant, AnnotationData, Iterable[Genotype])]): Unit = {
    val variants = data.map(_._1)
    val pw = new PrintWriter(vcfForPartition)
    pw.println("##fileformat=VCFv4.1")
    pw.println("#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT")
    for (v <- variants)
      pw.println(v.contig + '\t' + v.start + "\t.\t" + v.ref + '\t' + v.alt + "\t.\t.\t")
    pw.close()
  }


  /**
   * Subclasses can override this to read in the annotaitons produced by the containerized program.
   */
  def readAnnotations(): Iterator[Map[String, String]]


}
